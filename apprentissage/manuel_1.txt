GÃ©nial. Voici un **manuel hyper dÃ©taillÃ©, clair et pÃ©dagogique**, qui reprend tout le cheminement â€” **de zÃ©ro** (sans prÃ©requis) jusquâ€™Ã  **voir le robot LIMO** sâ€™afficher dans **Gazebo Sim (GZ/Harmonic)** avec **ROS 2 Jazzy**.
Ã€ chaque Ã©tape, tu as : **ce quâ€™on fait**, **pourquoi on le fait**, **les commandes exactes**, **comment vÃ©rifier**, et **les erreurs typiques**.

> Ce guide synthÃ©tise et structure ce que tu as dÃ©jÃ  collectÃ© dans tes trois fichiers de notes â€” je renvoie aux passages dâ€™origine quand câ€™est pertinent.&#x20;

---

# 1) Les bases (en franÃ§ais simple)

## 1.1 Quâ€™est-ce que ROS 2 ?

ROS = **Robot Operating System**. Ce nâ€™est pas un â€œvrai OSâ€, mais un **ensemble dâ€™outils et de bibliothÃ¨ques** pour programmer des robots. On y parle en **nÅ“uds** (petits programmes) qui Ã©changent des **messages** via des **topics**. La version **ROS 2 Jazzy** est la version rÃ©cente que tu utilises.
Les outils en ligne de commande sâ€™Ã©crivent `ros2 ...` (ex. `ros2 launch`, `ros2 run`).&#x20;

## 1.2 Quâ€™est-ce que Gazebo Sim (GZ/Harmonic) ?

Câ€™est un **simulateur 3D** avec physique rÃ©aliste. Il **nâ€™est pas** ROS, mais on sait **les faire discuter** grÃ¢ce au paquet **ros\_gz**.
Gazebo **Classic** (ancien) â‰  **Gazebo Sim/Harmonic** (nouveau). Les **plugins** de lâ€™un ne fonctionnent pas dans lâ€™autre â€” dâ€™oÃ¹ quelques adaptations dÃ©crites plus loin.&#x20;

## 1.3 URDF, Xacro, meshesâ€¦ câ€™est quoi ?

* **URDF** : un **fichier texte** qui dÃ©crit la gÃ©omÃ©trie, les liaisons (joints), les masses, etc. dâ€™un robot.
* **Xacro** : un **URDF avec macros** (paramÃ¨tres, includes), plus pratique Ã  Ã©crire/maintenir ; on le â€œdÃ©plieâ€ en URDF avec lâ€™outil `xacro`.
* **Meshes** : les **modÃ¨les 3D** (fichiers `.dae`, `.stl`) utilisÃ©s pour lâ€™apparence.
* **robot\_state\_publisher (RSP)** : un nÅ“ud ROS qui lit lâ€™URDF et publie lâ€™**arbre de repÃ¨res (TF)**. **RSP nâ€™insÃ¨re rien** dans Gazebo â€” câ€™est important.&#x20;

---

# 2) Installer les outils indispensables (une seule fois)

### Commandes

```bash
sudo apt update
sudo apt install -y ros-jazzy-ros-gz ros-jazzy-ros-gz-sim \
                   ros-jazzy-robot-state-publisher ros-jazzy-xacro
sudo apt install -y gz-sim8   # (facultatif) outils CLI "gz ..."
```

### Pourquoi ?

* **ros-gz / ros-gz-sim** : la â€œcolleâ€ entre ROS 2 et Gazebo Sim.
* **RSP** : pour publier lâ€™URDF â†’ TF.
* **xacro** : pour transformer les `.xacro` en URDF.
* **gz-sim8** : utilitaires `gz` pour inspecter/diagnostiquer la sim.
  Câ€™est la trousse Ã  outils minimale pour faire ROS 2 â†” GZ.&#x20;

---

# 3) PrÃ©parer ton espace de travail (workspace)

### Commandes

```bash
mkdir -p ~/projet_limo_autonome/Autonomous-Vision-driven-LIMO/src
cd ~/projet_limo_autonome/Autonomous-Vision-driven-LIMO/src

# Projet principal
git clone https://github.com/Birry2001/Autonomous-Vision-driven-LIMO

# Paquets du robot AgileX
git clone https://github.com/agilexrobotics/limo_ros2.git
```

### Pourquoi ?

Un **workspace ROS 2** est un dossier avec `src/` contenant tes **packages**. On y met :

* le projet applicatif ;
* les paquets **LIMO** (description URDF, meshes, etc.).
  Ainsi, `colcon` peut **construire** et ROS peut **trouver** ces paquets.&#x20;

---

# 4) Compiler et â€œactiverâ€ les paquets

### Corriger un petit piÃ¨ge `limo_car` (au besoin)

Si tu voyais une erreur â€œ`log/ not found`â€, crÃ©e simplement le dossier :

```bash
mkdir -p ~/projet_limo_autonome/Autonomous-Vision-driven-LIMO/src/limo_ros2/limo_car/log
```

(Alternative â€œpropreâ€ : rendre `CMakeLists.txt` tolÃ©rant, mais le dossier vide suffit.)

### Construire + sourcer

```bash
cd ~/projet_limo_autonome/Autonomous-Vision-driven-LIMO
colcon build --packages-select limo_description limo_car
source install/setup.bash
```

### Pourquoi ?

* `colcon build` fabrique un **overlay** dans `install/` avec ce que tes paquets exposent (fichiers, launch, etc.).
* `source install/setup.bash` â€œ**active**â€ cet overlay pour ce terminal : dÃ©sormais, `ros2` saura **oÃ¹ trouver** `limo_description` et ses fichiers.&#x20;

---

# 5) Adapter le modÃ¨le LIMO pour **Gazebo Sim (GZ)**

Les fichiers dâ€™origine incluent des **plugins Gazebo Classic** (ex. `libgazebo_ros_*`) incompatibles avec GZ. On crÃ©e donc une **variante Xacro â€œGZâ€** :

* **on supprime** toute inclusion `.gazebo` (qui amÃ¨ne des plugins Classic) ;
* **on rend les chemins de mesh infaillibles** en les passant en **chemins absolus** `file://...` vers lâ€™**installation** du paquet.

### Commandes (expliquÃ©es)

```bash
cd src/limo_ros2/limo_description/urdf

# 1) Dupliquer le Xacro
cp limo_ackerman.xacro limo_ackerman_gz.xacro

# 2) Retirer toutes les lignes qui incluent des plugins "Classic"
sed -i '/\.gazebo/d' limo_ackerman_gz.xacro
# â†’ "supprime (d) les lignes contenant '.gazebo' (motif regex) directement dans le fichier (-i)".
#   Câ€™est exactement ce que fait cette commande sed. :contentReference[oaicite:7]{index=7}

# 3) Calculer le chemin dâ€™installation du paquet ROS "limo_description"
PKG=$(ros2 pkg prefix limo_description)
# â†’ "ros2 pkg prefix <pkg>" renvoie lâ€™endroit oÃ¹ le paquet est installÃ© ; on le met dans la variable PKG. :contentReference[oaicite:8]{index=8}

# 4) Remplacer toutes les URI de meshes par des chemins absolus "file://..."
sed -i "s#model://limo_description/meshes/#file://${PKG}/share/limo_description/meshes/#g" limo_ackerman_gz.xacro
sed -i "s#package://limo_description/meshes/#file://${PKG}/share/limo_description/meshes/#g" limo_ackerman_gz.xacro
sed -i "s#file://\\\$(find limo_description)/meshes/#file://${PKG}/share/limo_description/meshes/#g" limo_ackerman_gz.xacro
# â†’ ces 3 remplacements couvrent tous les styles courants (model://, package://, $(find ...)).
#   RÃ©sultat : GZ retrouvera toujours les modÃ¨les 3D, sans dÃ©pendre dâ€™un registre "model://". :contentReference[oaicite:9]{index=9}
```

> **Optionnel** : ajouter 3 `<material>` (laser/camera/imu) dans `<robot ...>` pour supprimer des warnings purement esthÃ©tiques (couleurs manquantes).&#x20;

---

# 6) Lancer le simulateur correctement

### Commandes (Terminal A â€“ le laisser ouvert)

```bash
# a) Mettre tout le monde sur la mÃªme "partition" (canal interne de GZ)
export GZ_PARTITION=ros_limo
# â†’ "export VAR=..." crÃ©e une variable dâ€™environnement lisible par les programmes lancÃ©s depuis ce shell. :contentReference[oaicite:11]{index=11}

# b) Aider GZ Ã  trouver des ressources locales
cd ~/projet_limo_autonome/Autonomous-Vision-driven-LIMO
export GZ_SIM_RESOURCE_PATH=$GZ_SIM_RESOURCE_PATH:$(pwd)/src/limo_ros2/limo_description:$(pwd)/src/limo_ros2/limo_car
# â†’ on ajoute deux dossiers Ã  GZ_SIM_RESOURCE_PATH (comme PATH) pour que GZ sache oÃ¹ chercher. :contentReference[oaicite:12]{index=12}

# c) DÃ©marrer Gazebo Sim sur un monde "empty"
ros2 launch ros_gz_sim gz_sim.launch.py gz_args:='-r -v 4 empty.sdf'
# â†’ lance GZ via ROS ; "-r" = run auto, "-v 4" = logs dÃ©taillÃ©s, "empty.sdf" = monde vide de base. :contentReference[oaicite:13]{index=13}
```

### Pourquoi ?

* **MÃªme partition** partout â‡’ le spawner et le serveur **se voient**.
* **Ressources** â‡’ les meshes et autres fichiers seront rÃ©solus.
* **Monde connu** â‡’ on sait prÃ©cisÃ©ment oÃ¹ insÃ©rer le robot (â€œemptyâ€).&#x20;

---

# 7) GÃ©nÃ©rer lâ€™URDF dÃ©pliÃ© et **insÃ©rer** le robot dans le monde

### Commandes (Terminal B â€“ nouveau, avec les mÃªmes exports que A)

```bash
export GZ_PARTITION=ros_limo
cd ~/projet_limo_autonome/Autonomous-Vision-driven-LIMO
export GZ_SIM_RESOURCE_PATH=$GZ_SIM_RESOURCE_PATH:$(pwd)/src/limo_ros2/limo_description:$(pwd)/src/limo_ros2/limo_car

# 1) Xacro â†’ URDF "plat" (texte)
xacro src/limo_ros2/limo_description/urdf/limo_ackerman_gz.xacro > /tmp/limo_gz.urdf

# 2) Spawner lâ€™URDF dans le monde "empty"
ros2 run ros_gz_sim create \
  -world empty \
  -name limo \
  -allow_renaming true \
  -file /tmp/limo_gz.urdf \
  -x 0 -y 0 -z 0.2
```

### Pourquoi ?

* `xacro` **dÃ©plie** les macros pour donner un **URDF** simple que GZ sait convertir en SDF.
* `ros_gz_sim create` est le **spawner** : il **parle au serveur GZ** et lui demande dâ€™insÃ©rer ce robot **dans ce monde, Ã  cette pose**.
* `-allow_renaming true` Ã©vite lâ€™Ã©chec si un `limo` existe dÃ©jÃ  (`limo_1`, etc.).
* `-z 0.2` Ã©vite quâ€™il â€œnaisseâ€ en collision avec le sol.&#x20;

### Comment vÃ©rifier ?

* Dans la console de Gazebo (Terminal A), tu vois â€œ**Created entity â€¦ named \[limo]**â€.
* Dans la GUI, le robot apparaÃ®t (mÃªme si, pour lâ€™instant, il **ne bouge pas** â€” câ€™est normal, on nâ€™a pas encore ajoutÃ© de â€œcerveau moteurâ€ via plugin GZ).&#x20;

---

# 8) DÃ©pannage express (les cas frÃ©quents)

* **Rien ne sâ€™insÃ¨re / â€œWaiting for service /world/.../createâ€**
  â†’ Ce terminal nâ€™est **pas** sur la mÃªme **partition** que GZ. Remets `export GZ_PARTITION=ros_limo` dans **tous** les terminaux et relance `create`.&#x20;
* **â€œEntity named \[limo] already existsâ€**
  â†’ Supprime lâ€™entitÃ© via la GUI (clic droit â†’ Remove) **ou** garde `-allow_renaming true`.&#x20;
* **Meshes introuvables / robot â€œgrisâ€**
  â†’ Revois lâ€™Ã©tape 5 (remplacements `sed` â†’ `file://${PKG}/share/...`) **et** lâ€™export `GZ_SIM_RESOURCE_PATH` de lâ€™Ã©tape 6.&#x20;
* **Warnings â€œmaterial undefinedâ€**
  â†’ Sans impact ; optionnellement, ajoute 3 `<material>` (laser/camera/imu) pour les faire disparaÃ®tre.&#x20;

---

# 9) Ce que tu as maintenantâ€¦ et la suite logique

âœ… Tu as :

* un **modÃ¨le LIMO** qui **se charge** sans erreurs dans **GZ/Harmonic**,
* des meshes **rÃ©solus**,
* un **workflow reproductible** (lancer GZ â†’ gÃ©nÃ©rer URDF â†’ spawner).

ğŸ”œ Prochaine Ã©tape (quand tu veux) :

* **ajouter un plugin GZ de conduite** (Ackermann fidÃ¨le au LIMO Pro, ou DiffDrive plus simple) pour appliquer des efforts aux roues et publier lâ€™odomÃ©trie cÃ´tÃ© GZ ;
* **ouvrir le bridge ros\_gz** pour relier les topics GZ â†” ROS (par ex. `/cmd_vel` â†” `/model/limo/cmd_vel`, `/odom` â†” `/model/limo/odometry`) ;
* tester avec `teleop_twist_keyboard` pour **piloter** le robot au clavier.
  Je peux te fournir un **bloc `<plugin>` prÃªt Ã  coller** + la **commande bridge** assortie, au choix **Ackermann** ou **DiffDrive**.&#x20;

---

## Annexe A â€” Comprendre les commandes â€œcrucialesâ€ (dÃ©composÃ©es)

* `sed -i '/\.gazebo/d' ...`
  â†’ **supprime en place** toutes les lignes qui contiennent `.gazebo` (on retire les plugins Classic).&#x20;

* `export GZ_PARTITION=ros_limo`
  â†’ crÃ©e une **variable dâ€™environnement** lue par Gazebo ; tous les terminaux doivent partager cette **mÃªme valeur** pour se voir.&#x20;

* `export GZ_SIM_RESOURCE_PATH=...:$(pwd)/src/limo_ros2/limo_description:...`
  â†’ **ajoute** des rÃ©pertoires au **chemin de ressources** de GZ (comme on ajoute des rÃ©pertoires au `PATH`).&#x20;

* `PKG=$(ros2 pkg prefix limo_description)`
  â†’ stocke dans `PKG` le **chemin dâ€™installation** du paquet (pour construire des chemins `file://.../share/...`).&#x20;

* `ros2 launch ros_gz_sim gz_sim.launch.py gz_args:='-r -v 4 empty.sdf'`
  â†’ lance **Gazebo Sim** via ROS 2, en mode â€œrunâ€, logs verbeux, monde `empty.sdf`.&#x20;

* `ros2 run ros_gz_sim create -world empty -file /tmp/limo_gz.urdf ...`
  â†’ **insÃ¨re** (spawn) un robot **dans** le monde en cours, Ã  la pose donnÃ©e.&#x20;

---

## Annexe B â€” Glossaire ultra-court

* **Workspace ROS 2** : dossier contenant les **packages** (dans `src/`) Ã  **construire** avec `colcon`.
* **Package** : unitÃ© ROS 2 (code, ressources, fichiers launch).
* **URDF** : description du robot (liens, joints, inerties, collisions, visuels).
* **Xacro** : URDF avec macros/paramÃ¨tres.
* **RSP** : `robot_state_publisher`, publie lâ€™arbre TF Ã  partir de lâ€™URDF.
* **GZ/Harmonic** : Gazebo Sim nouvelle gÃ©nÃ©ration.
* **Gazebo Classic** : ancienne gÃ©nÃ©ration (plugins incompatibles avec GZ).
* **Spawn** : insÃ©rer un modÃ¨le dans un monde GZ qui tourne.

---

Si tu veux, je peux transformer ce manuel en **fichier Markdown (.md)** prÃªt Ã  partager/imprimer (ou en **PDF**). Tu me dis et je te le gÃ©nÃ¨re avec la structure ci-dessus.


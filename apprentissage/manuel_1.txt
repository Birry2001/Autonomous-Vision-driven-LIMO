Génial. Voici un **manuel hyper détaillé, clair et pédagogique**, qui reprend tout le cheminement — **de zéro** (sans prérequis) jusqu’à **voir le robot LIMO** s’afficher dans **Gazebo Sim (GZ/Harmonic)** avec **ROS 2 Jazzy**.
À chaque étape, tu as : **ce qu’on fait**, **pourquoi on le fait**, **les commandes exactes**, **comment vérifier**, et **les erreurs typiques**.

> Ce guide synthétise et structure ce que tu as déjà collecté dans tes trois fichiers de notes — je renvoie aux passages d’origine quand c’est pertinent.&#x20;

---

# 1) Les bases (en français simple)

## 1.1 Qu’est-ce que ROS 2 ?

ROS = **Robot Operating System**. Ce n’est pas un “vrai OS”, mais un **ensemble d’outils et de bibliothèques** pour programmer des robots. On y parle en **nœuds** (petits programmes) qui échangent des **messages** via des **topics**. La version **ROS 2 Jazzy** est la version récente que tu utilises.
Les outils en ligne de commande s’écrivent `ros2 ...` (ex. `ros2 launch`, `ros2 run`).&#x20;

## 1.2 Qu’est-ce que Gazebo Sim (GZ/Harmonic) ?

C’est un **simulateur 3D** avec physique réaliste. Il **n’est pas** ROS, mais on sait **les faire discuter** grâce au paquet **ros\_gz**.
Gazebo **Classic** (ancien) ≠ **Gazebo Sim/Harmonic** (nouveau). Les **plugins** de l’un ne fonctionnent pas dans l’autre — d’où quelques adaptations décrites plus loin.&#x20;

## 1.3 URDF, Xacro, meshes… c’est quoi ?

* **URDF** : un **fichier texte** qui décrit la géométrie, les liaisons (joints), les masses, etc. d’un robot.
* **Xacro** : un **URDF avec macros** (paramètres, includes), plus pratique à écrire/maintenir ; on le “déplie” en URDF avec l’outil `xacro`.
* **Meshes** : les **modèles 3D** (fichiers `.dae`, `.stl`) utilisés pour l’apparence.
* **robot\_state\_publisher (RSP)** : un nœud ROS qui lit l’URDF et publie l’**arbre de repères (TF)**. **RSP n’insère rien** dans Gazebo — c’est important.&#x20;

---

# 2) Installer les outils indispensables (une seule fois)

### Commandes

```bash
sudo apt update
sudo apt install -y ros-jazzy-ros-gz ros-jazzy-ros-gz-sim \
                   ros-jazzy-robot-state-publisher ros-jazzy-xacro
sudo apt install -y gz-sim8   # (facultatif) outils CLI "gz ..."
```

### Pourquoi ?

* **ros-gz / ros-gz-sim** : la “colle” entre ROS 2 et Gazebo Sim.
* **RSP** : pour publier l’URDF → TF.
* **xacro** : pour transformer les `.xacro` en URDF.
* **gz-sim8** : utilitaires `gz` pour inspecter/diagnostiquer la sim.
  C’est la trousse à outils minimale pour faire ROS 2 ↔ GZ.&#x20;

---

# 3) Préparer ton espace de travail (workspace)

### Commandes

```bash
mkdir -p ~/projet_limo_autonome/Autonomous-Vision-driven-LIMO/src
cd ~/projet_limo_autonome/Autonomous-Vision-driven-LIMO/src

# Projet principal
git clone https://github.com/Birry2001/Autonomous-Vision-driven-LIMO

# Paquets du robot AgileX
git clone https://github.com/agilexrobotics/limo_ros2.git
```

### Pourquoi ?

Un **workspace ROS 2** est un dossier avec `src/` contenant tes **packages**. On y met :

* le projet applicatif ;
* les paquets **LIMO** (description URDF, meshes, etc.).
  Ainsi, `colcon` peut **construire** et ROS peut **trouver** ces paquets.&#x20;

---

# 4) Compiler et “activer” les paquets

### Corriger un petit piège `limo_car` (au besoin)

Si tu voyais une erreur “`log/ not found`”, crée simplement le dossier :

```bash
mkdir -p ~/projet_limo_autonome/Autonomous-Vision-driven-LIMO/src/limo_ros2/limo_car/log
```

(Alternative “propre” : rendre `CMakeLists.txt` tolérant, mais le dossier vide suffit.)

### Construire + sourcer

```bash
cd ~/projet_limo_autonome/Autonomous-Vision-driven-LIMO
colcon build --packages-select limo_description limo_car
source install/setup.bash
```

### Pourquoi ?

* `colcon build` fabrique un **overlay** dans `install/` avec ce que tes paquets exposent (fichiers, launch, etc.).
* `source install/setup.bash` “**active**” cet overlay pour ce terminal : désormais, `ros2` saura **où trouver** `limo_description` et ses fichiers.&#x20;

---

# 5) Adapter le modèle LIMO pour **Gazebo Sim (GZ)**

Les fichiers d’origine incluent des **plugins Gazebo Classic** (ex. `libgazebo_ros_*`) incompatibles avec GZ. On crée donc une **variante Xacro “GZ”** :

* **on supprime** toute inclusion `.gazebo` (qui amène des plugins Classic) ;
* **on rend les chemins de mesh infaillibles** en les passant en **chemins absolus** `file://...` vers l’**installation** du paquet.

### Commandes (expliquées)

```bash
cd src/limo_ros2/limo_description/urdf

# 1) Dupliquer le Xacro
cp limo_ackerman.xacro limo_ackerman_gz.xacro

# 2) Retirer toutes les lignes qui incluent des plugins "Classic"
sed -i '/\.gazebo/d' limo_ackerman_gz.xacro
# → "supprime (d) les lignes contenant '.gazebo' (motif regex) directement dans le fichier (-i)".
#   C’est exactement ce que fait cette commande sed. :contentReference[oaicite:7]{index=7}

# 3) Calculer le chemin d’installation du paquet ROS "limo_description"
PKG=$(ros2 pkg prefix limo_description)
# → "ros2 pkg prefix <pkg>" renvoie l’endroit où le paquet est installé ; on le met dans la variable PKG. :contentReference[oaicite:8]{index=8}

# 4) Remplacer toutes les URI de meshes par des chemins absolus "file://..."
sed -i "s#model://limo_description/meshes/#file://${PKG}/share/limo_description/meshes/#g" limo_ackerman_gz.xacro
sed -i "s#package://limo_description/meshes/#file://${PKG}/share/limo_description/meshes/#g" limo_ackerman_gz.xacro
sed -i "s#file://\\\$(find limo_description)/meshes/#file://${PKG}/share/limo_description/meshes/#g" limo_ackerman_gz.xacro
# → ces 3 remplacements couvrent tous les styles courants (model://, package://, $(find ...)).
#   Résultat : GZ retrouvera toujours les modèles 3D, sans dépendre d’un registre "model://". :contentReference[oaicite:9]{index=9}
```

> **Optionnel** : ajouter 3 `<material>` (laser/camera/imu) dans `<robot ...>` pour supprimer des warnings purement esthétiques (couleurs manquantes).&#x20;

---

# 6) Lancer le simulateur correctement

### Commandes (Terminal A – le laisser ouvert)

```bash
# a) Mettre tout le monde sur la même "partition" (canal interne de GZ)
export GZ_PARTITION=ros_limo
# → "export VAR=..." crée une variable d’environnement lisible par les programmes lancés depuis ce shell. :contentReference[oaicite:11]{index=11}

# b) Aider GZ à trouver des ressources locales
cd ~/projet_limo_autonome/Autonomous-Vision-driven-LIMO
export GZ_SIM_RESOURCE_PATH=$GZ_SIM_RESOURCE_PATH:$(pwd)/src/limo_ros2/limo_description:$(pwd)/src/limo_ros2/limo_car
# → on ajoute deux dossiers à GZ_SIM_RESOURCE_PATH (comme PATH) pour que GZ sache où chercher. :contentReference[oaicite:12]{index=12}

# c) Démarrer Gazebo Sim sur un monde "empty"
ros2 launch ros_gz_sim gz_sim.launch.py gz_args:='-r -v 4 empty.sdf'
# → lance GZ via ROS ; "-r" = run auto, "-v 4" = logs détaillés, "empty.sdf" = monde vide de base. :contentReference[oaicite:13]{index=13}
```

### Pourquoi ?

* **Même partition** partout ⇒ le spawner et le serveur **se voient**.
* **Ressources** ⇒ les meshes et autres fichiers seront résolus.
* **Monde connu** ⇒ on sait précisément où insérer le robot (“empty”).&#x20;

---

# 7) Générer l’URDF déplié et **insérer** le robot dans le monde

### Commandes (Terminal B – nouveau, avec les mêmes exports que A)

```bash
export GZ_PARTITION=ros_limo
cd ~/projet_limo_autonome/Autonomous-Vision-driven-LIMO
export GZ_SIM_RESOURCE_PATH=$GZ_SIM_RESOURCE_PATH:$(pwd)/src/limo_ros2/limo_description:$(pwd)/src/limo_ros2/limo_car

# 1) Xacro → URDF "plat" (texte)
xacro src/limo_ros2/limo_description/urdf/limo_ackerman_gz.xacro > /tmp/limo_gz.urdf

# 2) Spawner l’URDF dans le monde "empty"
ros2 run ros_gz_sim create \
  -world empty \
  -name limo \
  -allow_renaming true \
  -file /tmp/limo_gz.urdf \
  -x 0 -y 0 -z 0.2
```

### Pourquoi ?

* `xacro` **déplie** les macros pour donner un **URDF** simple que GZ sait convertir en SDF.
* `ros_gz_sim create` est le **spawner** : il **parle au serveur GZ** et lui demande d’insérer ce robot **dans ce monde, à cette pose**.
* `-allow_renaming true` évite l’échec si un `limo` existe déjà (`limo_1`, etc.).
* `-z 0.2` évite qu’il “naisse” en collision avec le sol.&#x20;

### Comment vérifier ?

* Dans la console de Gazebo (Terminal A), tu vois “**Created entity … named \[limo]**”.
* Dans la GUI, le robot apparaît (même si, pour l’instant, il **ne bouge pas** — c’est normal, on n’a pas encore ajouté de “cerveau moteur” via plugin GZ).&#x20;

---

# 8) Dépannage express (les cas fréquents)

* **Rien ne s’insère / “Waiting for service /world/.../create”**
  → Ce terminal n’est **pas** sur la même **partition** que GZ. Remets `export GZ_PARTITION=ros_limo` dans **tous** les terminaux et relance `create`.&#x20;
* **“Entity named \[limo] already exists”**
  → Supprime l’entité via la GUI (clic droit → Remove) **ou** garde `-allow_renaming true`.&#x20;
* **Meshes introuvables / robot “gris”**
  → Revois l’étape 5 (remplacements `sed` → `file://${PKG}/share/...`) **et** l’export `GZ_SIM_RESOURCE_PATH` de l’étape 6.&#x20;
* **Warnings “material undefined”**
  → Sans impact ; optionnellement, ajoute 3 `<material>` (laser/camera/imu) pour les faire disparaître.&#x20;

---

# 9) Ce que tu as maintenant… et la suite logique

✅ Tu as :

* un **modèle LIMO** qui **se charge** sans erreurs dans **GZ/Harmonic**,
* des meshes **résolus**,
* un **workflow reproductible** (lancer GZ → générer URDF → spawner).

🔜 Prochaine étape (quand tu veux) :

* **ajouter un plugin GZ de conduite** (Ackermann fidèle au LIMO Pro, ou DiffDrive plus simple) pour appliquer des efforts aux roues et publier l’odométrie côté GZ ;
* **ouvrir le bridge ros\_gz** pour relier les topics GZ ↔ ROS (par ex. `/cmd_vel` ↔ `/model/limo/cmd_vel`, `/odom` ↔ `/model/limo/odometry`) ;
* tester avec `teleop_twist_keyboard` pour **piloter** le robot au clavier.
  Je peux te fournir un **bloc `<plugin>` prêt à coller** + la **commande bridge** assortie, au choix **Ackermann** ou **DiffDrive**.&#x20;

---

## Annexe A — Comprendre les commandes “cruciales” (décomposées)

* `sed -i '/\.gazebo/d' ...`
  → **supprime en place** toutes les lignes qui contiennent `.gazebo` (on retire les plugins Classic).&#x20;

* `export GZ_PARTITION=ros_limo`
  → crée une **variable d’environnement** lue par Gazebo ; tous les terminaux doivent partager cette **même valeur** pour se voir.&#x20;

* `export GZ_SIM_RESOURCE_PATH=...:$(pwd)/src/limo_ros2/limo_description:...`
  → **ajoute** des répertoires au **chemin de ressources** de GZ (comme on ajoute des répertoires au `PATH`).&#x20;

* `PKG=$(ros2 pkg prefix limo_description)`
  → stocke dans `PKG` le **chemin d’installation** du paquet (pour construire des chemins `file://.../share/...`).&#x20;

* `ros2 launch ros_gz_sim gz_sim.launch.py gz_args:='-r -v 4 empty.sdf'`
  → lance **Gazebo Sim** via ROS 2, en mode “run”, logs verbeux, monde `empty.sdf`.&#x20;

* `ros2 run ros_gz_sim create -world empty -file /tmp/limo_gz.urdf ...`
  → **insère** (spawn) un robot **dans** le monde en cours, à la pose donnée.&#x20;

---

## Annexe B — Glossaire ultra-court

* **Workspace ROS 2** : dossier contenant les **packages** (dans `src/`) à **construire** avec `colcon`.
* **Package** : unité ROS 2 (code, ressources, fichiers launch).
* **URDF** : description du robot (liens, joints, inerties, collisions, visuels).
* **Xacro** : URDF avec macros/paramètres.
* **RSP** : `robot_state_publisher`, publie l’arbre TF à partir de l’URDF.
* **GZ/Harmonic** : Gazebo Sim nouvelle génération.
* **Gazebo Classic** : ancienne génération (plugins incompatibles avec GZ).
* **Spawn** : insérer un modèle dans un monde GZ qui tourne.

---

Si tu veux, je peux transformer ce manuel en **fichier Markdown (.md)** prêt à partager/imprimer (ou en **PDF**). Tu me dis et je te le génère avec la structure ci-dessus.

